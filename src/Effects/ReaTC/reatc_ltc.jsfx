desc:ReaTC LTC Decoder / Generator
author:ReaTC
version:{{VERSION}}

// Dual-mode SMPTE/EBU LTC processor.
//
//   Source mode 0 - Transport: generates LTC from REAPER play position.
//   Source mode 1 - LTC Input: decodes LTC from incoming audio and
//                               re-clocks / mirrors it on the output.
//
// gmem layout - namespace "ReaTC_LTC" (CLAUDE.md protocol):
//   [0] TC_HOUR          JSFX -> Script   hours 0-23
//   [1] TC_MIN           JSFX -> Script   minutes 0-59
//   [2] TC_SEC           JSFX -> Script   seconds 0-59
//   [3] TC_FRAME         JSFX -> Script   frames 0-(fps-1)
//   [4] TC_FRAMERATE     JSFX -> Script   0=24 1=25 2=29.97DF 3=30
//   [5] TC_PLAY_STATE    JSFX -> Script   0=stop 1=play
//   [6] TC_VALID         JSFX -> Script   1=valid 0=invalid/not locked
//   [7] TC_WRITE_COUNTER JSFX -> Script   incremented each @block (staleness)
//   [8] SCRIPT_ALIVE     Script -> JSFX   incremented each Lua defer cycle
//
// Slider layout:
//   1-4   hours/minutes/seconds/frames  output, Lua reads via TrackFX_GetParam
//   5     locked flag 0/1              output
//   6     sequence counter             output
//   7     framerate type               input, Lua writes on change
//   8     threshold dB                 input, Lua writes on change
//   9     peak level 0-1              output (monitoring)
//   10    source mode                  user-facing: 0=Transport 1=LTC Input
//   11    output level dBFS            user-facing: LTC generator amplitude

slider1:0<0,23,1>-Hours
slider2:0<0,59,1>-Minutes
slider3:0<0,59,1>-Seconds
slider4:0<0,29,1>-Frames
slider5:0<0,1,1{Not locked,Locked}>-Locked
slider6:0<0,65535,1>-Sequence
slider7:1<0,3,1{24fps (Film),25fps (EBU),29.97 DF,30fps (SMPTE)}>-Framerate
slider8:-24<-48,-6,1>-Threshold dB
slider9:0<0,1,0.001>-Peak Level
slider10:0<0,1,1{Transport,LTC Input}>-Source Mode
slider11:-20<-40,0,1>-Output Level dBFS

@init

// gmem indices (CLAUDE.md) --------
TC_HOUR=0; TC_MIN=1; TC_SEC=2; TC_FRAME=3;
TC_FRAMERATE=4; TC_PLAY_STATE=5; TC_VALID=6;
TC_WRITE_COUNTER=7; SCRIPT_ALIVE=8;

// Use gmem directly (works with all REAPER versions)
// gmem_attach is optional in REAPER 6.32+; direct access still works

// Local memory layout --------
BIT_BUF   = 0;    // decoder ring buffer: 512 cells (indices 0..511)
GEN_FRAME = 512;  // encoder frame bits: 80 cells (indices 512..591)

// Decoder state --------
sig_state = 0;      // audio polarity: -1 (neg), 0 (deadband), +1 (pos)
bpm_state = 0;      // biphase-mark state: 0=at boundary, 1=mid-bit '1' seen
stt       = 0;      // samples since last transition
bit_idx   = 0;      // total bits pushed; ring index = bit_idx & 511
valid_samples = 0;  // countdown to lock expiry
dec_seq   = 0;      // decoded frame counter (wraps 0..65535)
peak_level = 0;     // peak input amplitude (linear)

// Decoded TC (written by decoder, read by @block for LTC mode)
dec_h=0; dec_m=0; dec_s=0; dec_f=0; dec_valid=0;

// Encoder state --------
// TC to encode (set from transport pos or decoded TC in @block)
enc_h=0; enc_m=0; enc_s=0; enc_f=0;
gen_bit_pos = 0;    // current bit in frame (0..79)
gen_phase   = 0.0;  // fractional phase within current half-bit (0..1)
gen_half    = 0;    // 0=first half, 1=second half of current bit
gen_out     = 1.0;  // current output polarity (+1 or -1)

// gfx state --------
gfx_prev_alive    = -1;
gfx_alive_timeout = 0;
gfx_alive_last_value = -1;
last_mouse_cap = 0;  // debounce clicks
ltc_detect_samples = 0;  // LTC auto-detect countdown (passive listen)

// Compute derived parameters from sliders --------
function update_params() (
  fps_type = floor(slider7);
  fps_int  = fps_type == 0 ? 24 : fps_type == 1 ? 25 : 30;

  // Decoder: amplitude threshold and bit-timing windows
  thr  = 10 ^ (slider8 / 20.0);
  spb  = srate / (fps_int * 80.0);   // samples per LTC bit
  mid  = spb * 0.75;                 // short/long gap boundary
  minb = spb * 0.25;                 // noise floor
  maxb = spb * 1.5;                  // framing-lost ceiling

  // Encoder: half-bit phase increment and output amplitude
  gen_phase_inc = fps_int * 80.0 * 2.0 / srate;  // 2 half-bits per bit
  enc_amp = 10 ^ (slider11 / 20.0);
);

// Non-drop-frame: seconds to TC --------
function tc_from_pos_ndf(pos) local(total, ts) (
  total = floor(pos * fps_int);
  enc_f = total % fps_int;
  ts    = floor(total / fps_int);
  enc_s = ts % 60;
  ts    = floor(ts / 60);
  enc_m = ts % 60;
  enc_h = floor(ts / 60) % 24;
);

// 29.97 drop-frame: seconds to TC --------
// SMPTE algorithm: skip frames 0 and 1 on every minute that is not a
// multiple of 10.  Correct for all 24-hour wrap cases.
function tc_from_pos_df(pos) local(total, d, mm, tf) (
  total = floor(pos * 30.0);          // nominal 30-fps display frame count
  d     = floor(total / 17982);       // completed 10-minute blocks
  mm    = total % 17982;              // frames within current 10-min block
  tf    = total + 18*d + 2*floor((mm - 2) / 1798);
  enc_h = floor(tf / 108000) % 24;
  enc_m = floor(tf / 1800)   % 60;
  enc_s = floor(tf / 30)     % 60;
  enc_f = tf % 30;
);

// Build encoder frame (80 bits) from enc_h/m/s/f --------
function build_enc_frame() local(f_u, f_t, s_u, s_t, m_u, m_t, h_u, h_t,
                                  sw, i, ones) (
  // Clear
  i = 0; loop(80, mem[GEN_FRAME + i] = 0; i += 1;);

  // BCD decompose
  f_u = enc_f % 10; f_t = floor(enc_f / 10);
  s_u = enc_s % 10; s_t = floor(enc_s / 10);
  m_u = enc_m % 10; m_t = floor(enc_m / 10);
  h_u = enc_h % 10; h_t = floor(enc_h / 10);

  // Bits 0-3: frame units
  mem[GEN_FRAME+0]=(f_u>>0)&1; mem[GEN_FRAME+1]=(f_u>>1)&1;
  mem[GEN_FRAME+2]=(f_u>>2)&1; mem[GEN_FRAME+3]=(f_u>>3)&1;
  // Bits 4-7: user bits group 1 — zero
  // Bits 8-9: frame tens
  mem[GEN_FRAME+8]=(f_t>>0)&1; mem[GEN_FRAME+9]=(f_t>>1)&1;
  // Bit 10: drop-frame flag
  mem[GEN_FRAME+10] = (fps_type == 2) ? 1 : 0;
  // Bit 11: color frame — zero; bits 12-15: user bits 2 — zero
  // Bits 16-19: second units
  mem[GEN_FRAME+16]=(s_u>>0)&1; mem[GEN_FRAME+17]=(s_u>>1)&1;
  mem[GEN_FRAME+18]=(s_u>>2)&1; mem[GEN_FRAME+19]=(s_u>>3)&1;
  // Bits 20-23: user bits 3 — zero
  // Bits 24-26: second tens
  mem[GEN_FRAME+24]=(s_t>>0)&1; mem[GEN_FRAME+25]=(s_t>>1)&1;
  mem[GEN_FRAME+26]=(s_t>>2)&1;
  // Bit 27: biphase mark correction — computed below
  // Bits 28-31: user bits 4 — zero
  // Bits 32-35: minute units
  mem[GEN_FRAME+32]=(m_u>>0)&1; mem[GEN_FRAME+33]=(m_u>>1)&1;
  mem[GEN_FRAME+34]=(m_u>>2)&1; mem[GEN_FRAME+35]=(m_u>>3)&1;
  // Bits 36-39: user bits 5 — zero
  // Bits 40-42: minute tens
  mem[GEN_FRAME+40]=(m_t>>0)&1; mem[GEN_FRAME+41]=(m_t>>1)&1;
  mem[GEN_FRAME+42]=(m_t>>2)&1;
  // Bit 43: binary group flag — zero; bits 44-47: user bits 6 — zero
  // Bits 48-51: hour units
  mem[GEN_FRAME+48]=(h_u>>0)&1; mem[GEN_FRAME+49]=(h_u>>1)&1;
  mem[GEN_FRAME+50]=(h_u>>2)&1; mem[GEN_FRAME+51]=(h_u>>3)&1;
  // Bits 52-55: user bits 7 — zero
  // Bits 56-57: hour tens
  mem[GEN_FRAME+56]=(h_t>>0)&1; mem[GEN_FRAME+57]=(h_t>>1)&1;
  // Bits 58-59: binary group flags — zero; bits 60-63: user bits 8 — zero
  // Bits 64-79: sync word 0x3FFD stored LSB-first
  sw = 0x3FFD; i = 0;
  loop(16, mem[GEN_FRAME+64+i] = (sw>>i)&1; i += 1;);

  // Biphase mark correction (bit 27): set so total '1' count is even,
  // which makes total transitions per frame (80 + ones) even.
  ones = 0; i = 0;
  loop(27, ones += mem[GEN_FRAME+i]; i += 1;);
  i = 28; loop(52, ones += mem[GEN_FRAME+i]; i += 1;);
  mem[GEN_FRAME+27] = ones & 1;
);

// Decoder helpers --------
function extract_bits(start, off, cnt) local(r, i) (
  r = 0; i = 0;
  loop(cnt,
    r |= mem[BIT_BUF + ((start + off + i) & 511)] << i;
    i += 1;
  );
  r
);

function check_sync() local(wl, wm, i, bv, fs,
                             f_u,f_t,s_u,s_t,m_u,m_t,h_u,h_t,
                             fr, sr, mr, hr) (
  wl = 0; wm = 0; i = 0;
  loop(16,
    bv  = mem[BIT_BUF + ((bit_idx - 16 + i) & 511)];
    wl |= bv << i;
    wm |= bv << (15 - i);
    i  += 1;
  );
  (wl == 0x3FFD || wl == 0xBFFC || wm == 0x3FFD || wm == 0xBFFC) ? (
    fs  = bit_idx - 80;
    f_u = extract_bits(fs,  0, 4); f_t = extract_bits(fs,  8, 2);
    s_u = extract_bits(fs, 16, 4); s_t = extract_bits(fs, 24, 3);
    m_u = extract_bits(fs, 32, 4); m_t = extract_bits(fs, 40, 3);
    h_u = extract_bits(fs, 48, 4); h_t = extract_bits(fs, 56, 2);
    fr = f_t*10 + f_u; sr = s_t*10 + s_u;
    mr = m_t*10 + m_u; hr = h_t*10 + h_u;
    fr < fps_int && sr < 60 && mr < 60 && hr < 24 ? (
      dec_h = hr; dec_m = mr; dec_s = sr; dec_f = fr;
      dec_valid = 1;
      dec_seq = (dec_seq + 1) & 65535;
      valid_samples = floor(srate * 0.5);
    );
  );
);

function push_bit(b) (
  mem[BIT_BUF + (bit_idx & 511)] = b;
  bit_idx += 1;
  bit_idx >= 80 ? check_sync();
);

// Initialise --------
update_params();
build_enc_frame();


@slider

update_params();
build_enc_frame();


@block

src_mode = floor(slider10);

// Determine TC for encoder --------
src_mode == 0 ? (
  // Transport mode: derive TC from REAPER play position
  fps_type == 2 ? tc_from_pos_df(play_position) : tc_from_pos_ndf(play_position);
  dec_valid = 1;
  dec_seq = (dec_seq + 1) & 65535;  // Lua needs seq changes to read TC
) : (
  // LTC input mode: mirror last decoded TC (if valid)
  dec_valid ? (enc_h=dec_h; enc_m=dec_m; enc_s=dec_s; enc_f=dec_f;);
);

is_playing = (play_state & 1) ? 1 : 0;

// Write gmem (CLAUDE.md protocol) --------
gmem[TC_HOUR]          = enc_h;
gmem[TC_MIN]           = enc_m;
gmem[TC_SEC]           = enc_s;
gmem[TC_FRAME]         = enc_f;
gmem[TC_FRAMERATE]     = fps_type;
gmem[TC_PLAY_STATE]    = is_playing;
gmem[TC_VALID]         = dec_valid;
gmem[TC_WRITE_COUNTER] = (gmem[TC_WRITE_COUNTER] + 1) & 65535;

// Mirror to sliders for Lua TrackFX_GetParam readback --------
// Sliders 1-6: TC fields + lock + seq; slider9: peak
// Mask bits: slider1=bit0 .. slider6=bit5, slider9=bit8 → 0x13F
slider1=enc_h; slider2=enc_m; slider3=enc_s; slider4=enc_f;
slider5=dec_valid; slider6=dec_seq; slider9=peak_level;
sliderchange(0x13F);

// Peak decay (~10 dB/s) --------
peak_level *= exp(log(0.316) * samplesblock / srate);

// LTC lock expiry --------
valid_samples > 0 ? (
  valid_samples -= samplesblock;
  valid_samples <= 0 ? (valid_samples = 0; dec_valid = 0;);
);


@sample

// LTC Decoder (active in LTC input mode) --------
// Also passively listens in Transport mode for LTC detect indicator
s     = (spl0 + spl1) * 0.5;
abs_s = abs(s);

src_mode == 1 ? (
  abs_s > peak_level ? (peak_level = abs_s);

  ns = s > thr ? 1 : s < -thr ? -1 : 0;
  ns != 0 && ns != sig_state ? (
    sig_state = ns;
    gap = stt; stt = 0;
    gap < minb ? (
      bpm_state = 0;
    ) : gap < mid ? (
      bpm_state == 0 ? bpm_state = 1 : (push_bit(1); bpm_state = 0;);
    ) : gap < maxb ? (
      bpm_state == 0 ? push_bit(0) : (push_bit(1); bpm_state = 0;);
    ) : (
      bpm_state = 0;
    );
  ) : (stt += 1;);
) : (
  // Transport mode: passive LTC detection (check if signal exceeds threshold)
  abs_s > thr ? (
    ltc_detect_samples = floor(srate * 1.0);  // keep indicator alive for 1 sec
  );
  ltc_detect_samples > 0 ? (ltc_detect_samples -= 1;);
  peak_level *= exp(log(0.316) * samplesblock / srate);
);

// LTC Encoder (biphase mark coding) — Transport mode only --------
// Each bit occupies two half-bits.  Always transition at the bit boundary
// (start of first half); add a mid-bit transition only for '1' bits.
src_mode == 0 ? (
  gen_phase += gen_phase_inc;
  gen_phase >= 1.0 ? (
    gen_phase -= 1.0;
    gen_half == 0 ? (
      // End of first half → second half: mid-bit transition for '1' bits only
      gen_half = 1;
      mem[GEN_FRAME + gen_bit_pos] ? (gen_out = -gen_out;);
    ) : (
      // End of second half → next bit boundary: always transition
      gen_half = 0;
      gen_out  = -gen_out;
      gen_bit_pos = (gen_bit_pos + 1) % 80;
      // At frame start, rebuild frame from current enc_* (set in @block)
      gen_bit_pos == 0 ? build_enc_frame();
    );
  );
  
  // Output: overwrite track audio with LTC signal
  spl0 = gen_out * enc_amp;
  spl1 = gen_out * enc_amp;
);


@gfx 580 240

// Common state
gfx_src = floor(slider10);
gfx_vld = gmem[TC_VALID];
ltc_detected = ltc_detect_samples > 0;

// Background: tint changes with mode
gfx_src == 0 ? (
  gfx_r=0.08; gfx_g=0.08; gfx_b=0.12;  // Transport: cool blue-black
) : (
  gfx_r=0.10; gfx_g=0.08; gfx_b=0.06;  // LTC Input: warm dark
);
gfx_a=1;
gfx_rect(0, 0, gfx_w, gfx_h, 1);

// Script-alive computation
current_alive = gmem[SCRIPT_ALIVE];
alive_changed = (current_alive != gfx_alive_last_value);
gfx_alive_last_value = current_alive;
alive_changed ? (gfx_alive_timeout = 60;);
gfx_alive_timeout > 0 ? (gfx_alive_timeout -= 1;);
script_running = gfx_alive_timeout > 0;

// ── Layout ──
pad = 12;
ctl_strip_h = 54;

panel_x = pad;
panel_y = pad;
panel_w = gfx_w - pad * 2;
panel_h = gfx_h - pad * 2;

// Panel background
gfx_r=0.11; gfx_g=0.12; gfx_b=0.16; gfx_a=1;
gfx_rect(panel_x, panel_y, panel_w, panel_h, 1);
// Panel border
gfx_r=0.22; gfx_g=0.24; gfx_b=0.32;
gfx_rect(panel_x, panel_y, panel_w, 1, 1);
gfx_rect(panel_x, panel_y + panel_h - 1, panel_w, 1, 1);
gfx_rect(panel_x, panel_y, 1, panel_h, 1);
gfx_rect(panel_x + panel_w - 1, panel_y, 1, panel_h, 1);

// ── TC Section ──
tc_x = panel_x;
tc_y = panel_y;
tc_w = panel_w;
tc_h = panel_h - ctl_strip_h;

// Header: "TIMECODE" left, RUNNING/OFFLINE badge right
gfx_setfont(1, "Arial", 10, 'b');
gfx_r=0.55; gfx_g=0.58; gfx_b=0.68;
gfx_x = tc_x + 12; gfx_y = tc_y + 8;
gfx_drawstr("TIMECODE");

badge_w = 72; badge_h = 18;
badge_x = tc_x + tc_w - badge_w - 10;
badge_y = tc_y + 7;
script_running ? (
  gfx_r=0.14; gfx_g=0.52; gfx_b=0.30;
) : (
  gfx_r=0.50; gfx_g=0.25; gfx_b=0.25;
);
gfx_rect(badge_x, badge_y, badge_w, badge_h, 1);
gfx_setfont(1, "Arial", 9, 'b');
gfx_r=1; gfx_g=1; gfx_b=1;
strcpy(#alive_str, script_running ? "RUNNING" : "OFFLINE");
gfx_measurestr(#alive_str, atw, ath);
gfx_x = badge_x + (badge_w - atw) / 2;
gfx_y = badge_y + (badge_h - ath) / 2;
gfx_drawstr(#alive_str);

// TC digits — dynamic font, centered
tc_top_margin = 28;
tc_bot_margin = 22;
tc_zone_top = tc_y + tc_top_margin;
tc_zone_bot = tc_y + tc_h - tc_bot_margin;
tc_zone_h = tc_zone_bot - tc_zone_top;

// Drop-frame semicolon separator per SMPTE convention
fps_type == 2 ? (
  sprintf(#tc_str, "%02d:%02d:%02d;%02d", gmem[TC_HOUR], gmem[TC_MIN], gmem[TC_SEC], gmem[TC_FRAME]);
) : (
  sprintf(#tc_str, "%02d:%02d:%02d:%02d", gmem[TC_HOUR], gmem[TC_MIN], gmem[TC_SEC], gmem[TC_FRAME]);
);

// TC color
gfx_src == 1 && !gfx_vld ? (
  gfx_r=0.95; gfx_g=0.68; gfx_b=0.20;
) : gfx_vld ? (
  gfx_r=0.20; gfx_g=0.88; gfx_b=0.38;
) : (
  gfx_r=0.52; gfx_g=0.54; gfx_b=0.62;
);

// Dynamic font scaling
tc_avail_w = tc_w - 24;
tc_font_w = floor(tc_avail_w / 6.5);
tc_font_h = floor(tc_zone_h * 0.85);
tc_font = tc_font_w < tc_font_h ? tc_font_w : tc_font_h;
tc_font < 20 ? tc_font = 20;
tc_font > 200 ? tc_font = 200;

gfx_setfont(1, "Courier New", tc_font, 'b');
gfx_measurestr(#tc_str, tcw, tch);

tcw > tc_avail_w ? (
  tc_font = floor(tc_font * tc_avail_w / tcw);
  tc_font < 20 ? tc_font = 20;
  gfx_setfont(1, "Courier New", tc_font, 'b');
  gfx_measurestr(#tc_str, tcw, tch);
);

gfx_x = tc_x + (tc_w - tcw) / 2;
gfx_y = tc_zone_top + (tc_zone_h - tch) / 2;
gfx_y < tc_zone_top ? gfx_y = tc_zone_top;
gfx_drawstr(#tc_str);

// Status row
fps_type == 0 ? strcpy(#fps_str, "24fps") :
fps_type == 1 ? strcpy(#fps_str, "25fps") :
fps_type == 2 ? strcpy(#fps_str, "29.97DF") :
                strcpy(#fps_str, "30fps");

gfx_src == 0 ? (
  sprintf(#status_str, "Transport  |  Output: %d dBFS", floor(slider11));
) : gfx_vld ? (
  sprintf(#status_str, "LTC Locked");
) : (
  sprintf(#status_str, "Searching...");
);

gfx_setfont(1, "Arial", 10, 0);
gfx_r=0.55; gfx_g=0.58; gfx_b=0.68;
gfx_x = tc_x + 12; gfx_y = tc_y + tc_h - 18;
gfx_drawstr(#status_str);

gfx_measurestr(#fps_str, fpsw, fpsh);
gfx_x = tc_x + tc_w - fpsw - 12; gfx_y = tc_y + tc_h - 18;
gfx_drawstr(#fps_str);

// ── Divider ──
gfx_r=0.22; gfx_g=0.24; gfx_b=0.32;
ctl_y = tc_y + tc_h;
gfx_rect(panel_x + 1, ctl_y, panel_w - 2, 1, 1);

// ── Controls strip ──
ctl_x = panel_x;
ctl_w = panel_w;

btn_h = 24;
btn_y = ctl_y + (ctl_strip_h - btn_h) / 2;

// Mode button (prominent, clearly labeled)
mode_btn_x = ctl_x + 12;
mode_btn_w = 130;
mode_btn_y = btn_y;

gfx_src == 0 ? (gfx_r=0.20; gfx_g=0.42; gfx_b=0.75;) : (gfx_r=0.75; gfx_g=0.38; gfx_b=0.18;);
gfx_rect(mode_btn_x, mode_btn_y, mode_btn_w, btn_h, 1);
gfx_r=1; gfx_g=1; gfx_b=1;
gfx_setfont(1, "Arial", 11, 'b');
strcpy(#mode_text, gfx_src == 0 ? "Transport" : "LTC Input");
gfx_measurestr(#mode_text, mtw, mth);
gfx_x = mode_btn_x + (mode_btn_w - mtw) / 2;
gfx_y = mode_btn_y + (btn_h - mth) / 2;
gfx_drawstr(#mode_text);

// Mode description text
gfx_setfont(1, "Arial", 9, 0);
gfx_r=0.45; gfx_g=0.48; gfx_b=0.58;
gfx_src == 0 ? (
  strcpy(#mode_desc, "Generates LTC from timeline");
) : (
  strcpy(#mode_desc, "Decodes LTC from audio input");
);
gfx_x = mode_btn_x; gfx_y = mode_btn_y - 12;
gfx_drawstr(#mode_desc);

// LTC Detected indicator (Transport mode only, when LTC signal seen on input)
gfx_src == 0 && ltc_detected ? (
  det_x = mode_btn_x + mode_btn_w + 12;
  gfx_setfont(1, "Arial", 9, 'b');
  gfx_r=0.95; gfx_g=0.75; gfx_b=0.15;
  gfx_x = det_x; gfx_y = btn_y + (btn_h - 10) / 2;
  gfx_drawstr("LTC DETECTED");
);

// Threshold: right side of strip
thr_value_w = 48;
thr_value_x = ctl_x + ctl_w - thr_value_w - 12;
thr_label_x = ctl_x + ctl_w - 220;
thr_slider_x = thr_label_x;
thr_slider_w = thr_value_x - thr_slider_x - 8;
thr_slider_w < 60 ? thr_slider_w = 60;
thr_slider_h = 10;
thr_slider_y = btn_y + (btn_h - thr_slider_h) / 2;

// Label
gfx_setfont(1, "Arial", 9, 0);
gfx_r=0.50; gfx_g=0.53; gfx_b=0.62;
gfx_x = thr_label_x; gfx_y = thr_slider_y - 13;
gfx_drawstr("Threshold");

// Track
gfx_r=0.06; gfx_g=0.07; gfx_b=0.10;
gfx_rect(thr_slider_x, thr_slider_y, thr_slider_w, thr_slider_h, 1);
// Fill
thr_frac = (slider8 - (-48)) / 42;
thr_fill_w = thr_frac * thr_slider_w;
gfx_r=0.24; gfx_g=0.56; gfx_b=0.40;
gfx_rect(thr_slider_x, thr_slider_y, thr_fill_w, thr_slider_h, 1);

// Value readout
sprintf(#th_val_str, "%d dB", floor(slider8));
gfx_setfont(1, "Arial", 9, 'b');
gfx_r=0.78; gfx_g=0.80; gfx_b=0.88;
gfx_measurestr(#th_val_str, thvw, thvh);
gfx_x = thr_value_x + (thr_value_w - thvw) / 2;
gfx_y = thr_slider_y + (thr_slider_h - thvh) / 2;
gfx_drawstr(#th_val_str);

// ── Interaction: Mode button (debounced) ──
mode_btn_hit = mouse_x >= mode_btn_x && mouse_x < mode_btn_x + mode_btn_w && mouse_y >= mode_btn_y && mouse_y < mode_btn_y + btn_h;
mode_btn_clicked = mode_btn_hit && (mouse_cap & 1) && !(last_mouse_cap & 1);
mode_btn_clicked ? (
  slider10 = 1 - slider10;
  slider_automate(slider10);
);

// ── Interaction: Threshold slider drag ──
mouse_x >= thr_slider_x && mouse_x < thr_slider_x + thr_slider_w && mouse_y >= thr_slider_y - 4 && mouse_y < thr_slider_y + thr_slider_h + 4 && (mouse_cap & 1) ? (
  new_thr = -48 + ((mouse_x - thr_slider_x) / thr_slider_w) * 42;
  slider8 = max(-48, min(-6, new_thr));
  slider_automate(slider8);
);

// Save mouse state for debouncing
last_mouse_cap = mouse_cap;
