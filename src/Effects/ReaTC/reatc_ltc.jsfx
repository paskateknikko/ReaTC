desc:ReaTC LTC Decoder
author:ReaTC
version:{{VERSION}}

// Decodes SMPTE/EBU Linear Timecode (LTC) from audio in real-time.
// Writes decoded TC to gmem["ReaTC_LTC"] for JSFX-to-JSFX sharing
// and mirrors values to sliders for Lua readback via TrackFX_GetParam.
//
// gmem layout (namespace "ReaTC_LTC"):
//   [0] valid  — 1 = locked, 0 = no signal
//   [1] hours  — 0-23
//   [2] minutes — 0-59
//   [3] seconds — 0-59
//   [4] frames  — 0-(fps-1)
//   [5] seq     — frame counter, increments on each decoded frame (wraps at 65535)
//   [6] fps_type — 0=24fps  1=25fps  2=29.97DF  3=30fps
//
// Slider layout:
//   slider1-4  hours/minutes/seconds/frames  (output, read by Lua)
//   slider5    locked flag 0/1               (output, read by Lua)
//   slider6    sequence counter              (output, read by Lua)
//   slider7    framerate type               (input,  written by Lua)
//   slider8    threshold dB                 (input,  written by Lua)
//   slider9    peak level 0-1               (output, monitoring)

slider1:0<0,23,1>-Hours
slider2:0<0,59,1>-Minutes
slider3:0<0,59,1>-Seconds
slider4:0<0,29,1>-Frames
slider5:0<0,1,1{Not locked,Locked}>-Locked
slider6:0<0,65535,1>-Sequence
slider7:1<0,3,1{24fps (Film),25fps (EBU),29.97 DF,30fps (SMPTE)}>-Framerate
slider8:-24<-48,-6,1>-Threshold dB
slider9:0<0,1,0.001>-Peak Level

@init

gmem_attach("ReaTC_LTC");

// Bit circular buffer in local memory, indices 0..511
BIT_BUF = 0;

// Biphase-mark decoder state
sig_state = 0;   // current signal polarity: -1, 0 (deadband), 1
bpm_state = 0;   // 0 = at boundary, 1 = mid-bit of a '1' seen
stt       = 0;   // samples since last transition
bit_idx   = 0;   // total bits pushed (use & 511 for buffer index)

// Validity timeout
valid_samples = 0;   // samples remaining before declaring loss-of-lock

// Frame sequence counter and peak level
seq        = 0;
peak_level = 0;

function update_thresholds() (
  fps_type = floor(slider7);
  fps_int  = fps_type == 0 ? 24 : fps_type == 1 ? 25 : 30;
  spb      = srate / (fps_int * 80.0);  // samples per LTC bit
  thr      = 10 ^ (slider8 / 20.0);    // linear amplitude threshold
  mid      = spb * 0.75;               // short-gap / long-gap boundary
  minb     = spb * 0.25;               // minimum valid gap
  maxb     = spb * 1.5;                // maximum valid gap
);

// Extract LTC field from bit buffer starting at absolute index 'start',
// offset 'off' bits, reading 'cnt' bits, LSB-first.
function extract_bits(start off cnt) local(r i) (
  r = 0; i = 0;
  loop(cnt,
    r |= mem[BIT_BUF + ((start + off + i) & 511)] << i;
    i += 1;
  );
  r
);

// Check last 16 bits for LTC sync word and if found decode the 80-bit frame.
function check_sync() local(i bv wl wm fs f_u f_t s_u s_t m_u m_t h_u h_t fr sr mr hr) (
  wl = 0; wm = 0; i = 0;
  loop(16,
    bv = mem[BIT_BUF + ((bit_idx - 16 + i) & 511)];
    wl |= bv << i;
    wm |= bv << (15 - i);
    i  += 1;
  );

  (wl == 0x3FFD || wl == 0xBFFC || wm == 0x3FFD || wm == 0xBFFC) ? (
    fs   = bit_idx - 80;   // absolute start of 80-bit frame

    f_u  = extract_bits(fs,  0, 4);   // frame units
    f_t  = extract_bits(fs,  8, 2);   // frame tens
    s_u  = extract_bits(fs, 16, 4);   // second units
    s_t  = extract_bits(fs, 24, 3);   // second tens
    m_u  = extract_bits(fs, 32, 4);   // minute units
    m_t  = extract_bits(fs, 40, 3);   // minute tens
    h_u  = extract_bits(fs, 48, 4);   // hour units
    h_t  = extract_bits(fs, 56, 2);   // hour tens

    fr   = f_t * 10 + f_u;
    sr   = s_t * 10 + s_u;
    mr   = m_t * 10 + m_u;
    hr   = h_t * 10 + h_u;

    // Sanity-check decoded values before accepting
    fr < fps_int && sr < 60 && mr < 60 && hr < 24 ? (
      slider1 = hr;
      slider2 = mr;
      slider3 = sr;
      slider4 = fr;
      slider5 = 1;
      seq     = (seq + 1) & 65535;
      slider6 = seq;
      valid_samples = floor(srate * 0.5);
      sliderchange(63);  // notify host: sliders 1-6 updated

      // Write to shared gmem for other JSFX consumers
      gmem[0] = 1;
      gmem[1] = hr;
      gmem[2] = mr;
      gmem[3] = sr;
      gmem[4] = fr;
      gmem[5] = seq;
      gmem[6] = floor(slider7);
    );
  );
);

function push_bit(b) (
  mem[BIT_BUF + (bit_idx & 511)] = b;
  bit_idx += 1;
  bit_idx >= 80 ? check_sync();
);

update_thresholds();


@slider

update_thresholds();


@block

// Peak level decay: ~10 dB/s
peak_level *= exp(log(0.316) * samplesblock / srate);
slider9    = peak_level;

// Expire lock if no valid frame received recently
valid_samples > 0 ? (
  valid_samples -= samplesblock;
  valid_samples <= 0 ? (
    valid_samples = 0;
    slider5       = 0;
    gmem[0]       = 0;
    sliderchange(16);  // slider5 = bit 4
  );
);


@sample

// Mix stereo to mono
s     = (spl0 + spl1) * 0.5;
abs_s = abs(s);
abs_s > peak_level ? (peak_level = abs_s);

// Determine new polarity state (with deadband)
ns = s > thr ? 1 : s < -thr ? -1 : 0;

ns != 0 && ns != sig_state ? (
  sig_state = ns;
  gap = stt;
  stt = 0;

  gap < minb ? (
    // Too short — noise, reset
    bpm_state = 0;
  ) : gap < mid ? (
    // Short gap — mid-bit transition of a '1'
    bpm_state == 0 ? (
      bpm_state = 1;
    ) : (
      push_bit(1);
      bpm_state = 0;
    );
  ) : gap < maxb ? (
    // Long gap — bit boundary
    bpm_state == 0 ? (
      push_bit(0);
    ) : (
      push_bit(1);
      bpm_state = 0;
    );
  ) : (
    // Too long — framing lost
    bpm_state = 0;
  );
) : (
  stt += 1;
);

// Audio passes through unchanged
